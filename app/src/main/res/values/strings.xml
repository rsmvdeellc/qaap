<resources>
    <string name="app_name">QA-Шпаргалка</string>
        <string name="testirovanie_text"><b>Тестирование</b> — это процесс, содержащий в себе все активности жизненного цикла, как динамические, так и статические, касающиеся планирования, подготовки и оценки программного продукта и связанных с этим результатов работ с целью определить, что они соответствуют описанным требованиям, показать, что они подходят для заявленных целей и для определения дефектов. (ISTQB) \n\n

        <b>Процесс тестирования</b> включает в себя планирование работ, проектирование тестов, выполнение тестирования и анализ полученных результатов.  \n\n
        <b>Целью тестирования</b> является предоставление заинтересованным лицам информации об актуальном состоянии продукта. Сюда относятся проверки на выполненость требований, обнаружение и предотвращение дефектов, соответствие уровню качества. \n\n
        <b>Качество</b> - это совокупность характеристик продукта, которые относятся к способности продукта удовлетворить установленные и предполагаемые потребности. \n\n
        <b>Дефекты и ошибки</b> \n
        Ошибка - это действие человека, которое приводит к неправильному результату. Дефект - это изъян, который возникает вследсвтвие допущенной ошибки и может привести к отказу. Отказ - это невыполнение своих функций ПО. Найденные в процессе тестирования деекты - это баги. \n\n
        <b>Серьезность и приоритет</b> - серьезность представляет техническое влияние ошибки на работоспособность самого ПО, а приоритет указывает на очередность выполнения задачи или устранения дефекта, т.е. точку зрения бизнеса.\n\n
        <b>Градация серьезности</b> \n
        1. Критическая (critical) - существование дефекта приводит к масштабным последствиям катастрофического характера, например: потеря данных, раскрытие конфиденциальной информации, нарушение ключевой функциональности приложения и т.д. \n
        2. Высокая (major) - существование дефекта приносит ощутимые неудобства многим пользователям в рамках их типичной деятельности, например: недоступность вставки из буфера обмена, неработоспособность общепринятых клавиатурных комбинаций, необходимость перезапуска приложения при выполнении типичных сценариев работы. \n
        3. Средняя (medium) - существование дефекта слабо влияет на типичные сценарии работы пользователей, и/или существует обходной путь достижения цели, например: диалоговое окно не закрывается автоматически после нажатия кнопок «OK»/«Cancel», при распечатке нескольких документов подряд не сохраняется значение поля «Двусторонняя печать», перепутаны направления сортировок по некоему полю таблицы. \n
        4. Низкая (minor) - существование дефекта редко обнаруживается незначительным процентом пользователей и (почти) не влияет на их работу, например: опечатка в глубоко вложенном пункте меню настроек, некое окно сразу при отображении расположено неудобно (нужно перетянуть его в удобное место), неточно отображается время до завершения операции копирования файлов. \n\n
        <b>Градация приоритета</b> \n
        1. Наивысшая (ASAP, as soon as possible) срочность указывает на необходимость устранить дефект настолько быстро, насколько это возможно. \n
        2. Высокая (high) срочность означает, что дефект следует исправить вне очереди, т.к. его существование или уже объективно мешает работе, или начнёт создавать такие помехи в самом ближайшем будущем. \n
        3. Обычная (normal) срочность означает, что дефект следует исправить в порядке общей очередности. Такое значение срочности получает большинство дефектов. \n
        4. Низкая (low) срочность означает, что в обозримом будущем исправление данного дефекта не окажет существенного влияния на повышение качества продукта. \n\n\n
        </string>
    <string name="test_princ"><b>Принципы тестирования</b> являются общим руководством для тестирования. \n\n
    1. <b>Тестирование показывает наличие дефектов, а не их отсутствие.</b> Тестирование может показать наличие дефектов в ПО, но не может доказать, что их нет. Тестирование снижает вероятность наличия дефектов, но, даже если дефекты не удалось обнаружить, то это не означает, что их нет.  \n\n
    2. <b>Исчерпывающее тестирование недостижимо.</b> Провести исчерпывающее тестирование, которое бы покрывало все комбинации пользовательского ввода и состояний системы, невозможно. Необходимо использовать анализ рисков и расставить приоритеты, что позволит более эффективно организовать работу по обеспечению качества ПО. \n\n
    3. <b>Раннее тестирование сохраняет время и деньги.</b> Тестирование должно начинаться как можно раньше в жизненном цикле разработки ПО, что позволит найти дефекты на ранних стадиях. Раннее тестирование иногда называют «сдвигом влево». Тестирование на ранних этапах жизненного цикла разработки программного обеспечения помогает сократить или исключить дорогостоящие изменения. \n\n
    4. <b>Кластеризация дефектов (Скопление дефектов).</b> Данный принцип гласит, что небольшое количество модулей содержат в себе большинство багов. Это пример применения принципа Парето: 80% проблем содержатся в 20% модулей. \n\n
    5. <b>Парадокс (эффект) пестицида.</b> Система эволюционирует, поэтому старые тест-кейсы больше не реботают. Чтобы преодолеть этот парадокс, нужно периодически вносить изменения в наборы тестов, проводить их коррекцию таким образом, чтобы они отвечали новому состоянию системы и позволяли находить как можно большее количество дефектов. \n\n
    6. <b>Тестирование зависит от контекста.</b> Методолгия, техники и типы тестирования зависят от сути объекта тестирования. Например, медицинское ПО потребует более тщательных проверок, чем, например, компьютерная игра, а сайт с высокой посещаемостью должен пройти более серьезные проверки производительности. \n\n
    7. <b>Заблуждение об отсутствии ошибок.</b> Суть принципа: отсутствие дефектов - необходимое, но не достаточное условие хорошего ПО. Есть и другие факторы, влияющие на качество продукта. \n\n\n\n
    </string>
    <string name="test_qc">Все эти три термина явно связаны с обеспечением качества продукта. Однако, обеспечивают они его по-разному. И понимание данной разницы поможет еще больше осознать место тестировщика в процессе обеспечения качества. \n\n
    <b>Quality Assurance (QA, обеспечение качества)</b>- это совокупность мероприятий, охватывающих все технологические этапы разработки, выпуска и эксплуатации ПО для обеспечения требуемого уровня качества выпускаемого продукта. \n\n
    Специалист QA создает и реализует различные тактики для повышения качества на всех стадиях: подготовка и установка стандартов, анализ качества, выбор инструментов, предотвращение ошибок и постоянное усовершенствование процесса. То есть он собирает информацию о продукте и думает о том, как можно улучшить процесс разработки, какие методики внедрить/убрать в работе всех участников процесса: разработчиков, аналитиков и т.д. Основная задача — продумать и построить процессы разработки так, чтобы продукт был качественным и чтобы в нем было как можно меньше багов. \n\n
    <b>Quality Control (QC, контроль качества)</b> - это совокупность действий, проводимых над продуктом в процессе разработки, для получения информации о его актуальном состоянии в разрезах: «готовность продукта к выпуску», «соответствие зафиксированным требованиям», «соответствие заявленному уровню качества продукта». \n\n
    Специалист QC занимается анализом результатов тестирования и устранением обнаруженных дефектов. Это позволяет обеспечить соответствие продукта определенным требованиям, установленным на этапе обеспечения качества (QA). \n\n
    <b>Testing (тестирование)</b> - это уже непосредственно процесс проверки результатов работы на соответствие установленным требованиям. \n\n
    Тестировщик — это специалист, который занимается такой проверкой. То есть занимается реализацией того, что было запланировано на уровне QA. Основная задача — проверка соответствия продукта установленным требованиям. \n\n
    Testing — конкретные действия по проверке качества продукта. QC — контроль за данными действиями. QA — планирование того, как сделать продукт качественным. \n\n\n\n
    </string>
    <string name="test_verval"><b>Верификация и валидация</b> - имеют важное значение и уравновешивают друг друга. Каждый из процессов предоставляет свои фильтры ошибок. Оба процесса используются для обнаружения дефектов, но в разных плоскостях. Верификация используется для выявления ошибок в спецификациях требований, а валидация — для поиска дефектов в реализованном ПО.  \n\n
    <b>Верификация (verification)</b> - это процесс, который отвечает на вопрос "Правильно ли мы делаем продукт?". Он нужен для того, чтобы определить, соответствует ли ПО требованиям. Верификация связана с такими активностями, как ревью, совещания и инспекции. Верификация не подразумевает выполнение кода и проводится до валидации. Стоимость ошибок, выявленных при верификации, ниже, чем при валидации. Это, в основном, ручная проверка документов и файлов. \n\n
    <b>Валидация (validation)</b> - это процесс, который отвечает на вопрос "Правильный ли мы делаем продукт". Он нужен для того, чтобы определить, соответствует ли ПО ожиданиям и потребностям пользователя, требованиям. Валидация связана с такими активностями, как тестирование черного, белого и серого ящиков и т.п. Валидация проводится с запуском кода и после верификации. Ошибки, обнаруженные при валидации, обходятся дороже, чем найденные при верификации. Это проверка разработанного ПО, основанная на документах и файлах. \n\n
    </string>
    <string name="test_sdlc"><b>SDLC(Software Development Lifecycle)</b> и <b>STLS(Software Testing Lifecycle)</b> тесно связанные друг с другом понятия, преследующие разные задачи, но выполяющие одну цель - удовлетворение желания заказчика. SDLC отвечает за сбор требований с последующей разработкой заявленного функционала, а задача STLC - анализ требований и подтверждение качества реализованного функционала. \n\n
    <b>Этапы SDLC</b> \n
    1. Сбор и анализ требований. На данном этапе формулируются цели и задачи проекта, формируются и анализируются требования клиента, определяются сроки и стоимость, формируется ТЗ. \n
    2. Проектирование. На этапе проектирования программисты и архитекторы, основываясь на требованиях, разрабатывают дизайн-спецификацию (архитектура, интерфейс, железо, ЯП, БД). \n
    3. Разработка. Происходит непосредственно разработка ПО, создается прототип и рабочая версия. \n
    4. Тестирование и отладка. Происходит проверка ПО на соответствие требованиям, обнаружение дефектов. \n
    5. Развертывание. Происходит передача ПО клиенту, настройка, установка. \n
    6. Сопровождение. На данном этапе происходят мероприятия по поддержке ПО. \n
    Дополнительный этап - закрытие. Это самый последний этап жизненого цикла, на котором прекращается поддержка, ПО выводится из экплуатации или заменяется на более современные аналоги. \n\n
    <b>Этапы STLC</b> \n
    1. Анализ требований. На данном этапе происходит анализ требований с точки зрения QA, формирование критериев начала и окончания тестирования, определяется потребность в автоматизированном тестировании \n
    2. Планирование тестирования. На этапе планирования формируется стратегия и подход к тестированию, происходит выбор инструментов, оценка трудозатрат. \n
    3. Разработка тест-кейсов. Происходит разработка тест-кейсов на основании предыдущих пунктов. \n
    4. Настройка тестовой среды. Происходит настройка ПО для реализации разработанных тест-кейсов. \n
    5. Выполнение тестов. На данном этапе происходит выполнение тестов на основании созданной тестовой документации и настроенной тестовой среды. Все результаты выполнения тестов фиксируются и, в случае, выявления дефектов, направляются на доработку с последующей перепроверкой \n
    6. Завершение цикла испытаний. Формируется отчет о тестировании, с указанием затраченного времени, наличия дефектов, предложениями по улучшению. \n\n\n\n
    </string>
    <string name="test_req"><b>Требования</b> - это описание того, какие функции и с соблюдением каких условий должно выполнять ПО в процессе решения задач. \n\n
    <b>Прямые и косвенные требования </b> \n
    1. Пямые требования - это требования, которые явно указаны и прописаны в документации. \n
    2. Косвенные требования - это требования, которые явно не указаны и не прописаны в требованиях, но основаны на стандартах, опыте и здравом смысле. \n\n
    <b>Типы требований</b> \n
    1. Функциональные требования - описывают какие функции должно выполнять ПО с точки зрения бизнес-требований(с какой целью создается ПО), пользовательских требований(какие задачи сможет решать пользователь) и функциональных требований. \n
    2. Нефункциональные требования - описывают как ПО должно выполнять эти функции. Это окружение, производительность, интерфейс и т.д. \n\n
    <b>Источники требований</b> \n
    1. Клиент/заказчик \n
    2. Документы \n
    3. Мозговой штурм \n
    4. Фокус-группа \n
    5. Анкетирование \n
    6. Нормы/стандарты \n
    7. Лучшие практики \n
    8. Прототип \n
    9. Наблюдение \n
    10. Моделирование \n
    11. Конкуренты \n\n
    <b>Характеристики качественных требований</b> \n
    1. Полнота \n
    2. Однозначность \n
    3. Непротиворечивость \n
    4. Проверяемость \n
    5. Модифицируемость \n\n
    </string>
    <string name="test_api"><b>API (Application Programming Interface)</b> - это описание способов взаимодействия между программами, как они могут общаться и передавать данные друг другу. API состоит из двух частей: интерфейс взаимодействия и описание способов взимодействия. \n\n\n
    <b>REST API</b> - это архитектурный стиль, который базируется на протоколе HTTP, поддерживает обмен сообщениями в различных форматах: текст, HTML, YAML, XML, JSON. \n\n
    <b>Свойства архитектуры REST</b> \n
    1. Производительность. \n
    2. Масштабируемость. \n
    3. Простота. \n
    4. Модифицируемость. \n
    5. Видимость. \n
    6. Переносимость. \n
    7. Надежность. \n\n
    <b>Основные методы REST API</b> \n
    1. GET - чтение данных. \n
    2. POST - создание данных. \n
    3. PUT - изменение или обновление данных. \n
    4. DELETE - удаление данных. \n\n
    <b>Преимущества перед SOAP API</b> \n
    1. Простота использования и гибкость. \n
    2. Меньше кривая обучения. \n
    3. Различные форматы сообщений. \n
    4. Быстрота. \n\n\n
    <b>SOAP API</b> - это стандартизированный протокол, который не завист от языка и платформы, поддерживает обмен сообщениями только в формате XML. \n\n
    <b>Области применения SOAP API</b> \n
    Финансовые сервисы, e-commerce, телеком - сферы, где имеются транзакции и есть необходимость подтверждения. \n\n
    <b>Преимущества перед REST API</b> \n
    1. Не зависит от языка, платформы и транспртного уровня. \n
    2. Хорошо работает в распределенных корпоративных средах. \n
    3. Имеется встроенная обработка ошибок. \n\n\n
    </string>
    <string name="test_klass"><b>Классификация тестирования.</b> Тесты существенно различаются по задачам, которые с их помощью решаются, и по используемой технике. Различие задач тестирования приводит, естественным образом, к необходимости использовать весьма разнообразные типы (виды) тестирования. \n\n\n
    <b>По уровням</b> \n
    1. Юнит-тестирование (модульное тестирование) - это проверка каждого модуля (юнита, функции) по отдельности. \n
    2. Интеграционное тестирование - это проверка работы модулей вместе. \n
    3. Системное тестирование - это проверка функциональных и нефункциональных требований в системе в целом. \n
    4. Приемочное тестирование - определяет удовлетворяет ли система приемочным критериям. \n\n
    <b>По устройству (знанию кода)</b> \n
    1. Black Box - это метод функционального и нефункционального тестирования ПО без знаний о его внутреннем устройстве. \n
    2. Grey Box - это метод тестирования ПО с частичным знанием его внутреннего устройства. \n
    3. White Box - это метод тестирования ПО, которое предполагает знание его внутреннего устройства. \n\n
    <b>По выполнению кода (запуску ПО)</b> \n
    1. Статическое тестирование - это тестирование ПО, которое проводится без его запуска (документация, оформление). \n
    2. Динамическое тестирование - это тестирование функционала ПО во время его запуска. \n\n
    <b>По исполнению сценария</b> \n
    1. Ad-hoc-тестирование (интуитивное) - интуитивное и беспорядочное, осуществляется без подготовки к тестам, без определения ожидаемых результатов, проектирования тестовых сценариев. \n
    2. Исследовательское - вдумчивый подход к ad-hoc тестированию, неформальный метод проектирования тестов, при котором тестировщик активно контролирует проектирование тестов в то время, когда эти тесты выполняются, и использует полученную во время тестирования информацию для проектирования новых и улучшенных тестов.\n
    3. Сценарное - тестирование с использованием тескт-кейсов, чек-листов. \n\n
    <b>По объекту тестирования</b> \n
    1. Функциональное тестирование - это тестирование бизнес-логики ПО, подтверждение того, что ПО выполняет все заложенные в него функции (требования). \n
    2. Нефункциональное тестирование - это все то, что не вошло в функциональное тестирование и тестирование безопасности: тестирование UI/UX, GUI (внешний вид, логика использования), тестирование удобства пользования, тестирование производительности (нагрузочное тестировнаие, стресс-тестирование, отказ и восстановление, тестирование на стабильность), тестирование локализации и интернационализации, тестирование доступности. \n
    3. Тестирование безопасности - это тестирование безопасности. \n\n
    <b>По позитивности</b> \n
    1. Позитивное тестирование - это проверка работы функционала, которая описаны в требованиях. \n
    2. Негативное тестирование - это проверка работы функционала, которая не описана в требованиях. \n\n
    <b>По цели тестирования</b> \n
    1. Тестирование новой функциональности - это проверка нового функционала ПО. \n
    2. Регрессионное тестирование - это проверка того, что новые внесенные изменения не повлияли неблагоприятно на действующий функционал ПО. \n
    3. Ретест - это проверка того, что найденные ранее дефекты были исправлены. \n\n
    <b>По глубине тестирования</b> \n
    1. Smoke-тестирование - это проверка критически важных функциональных частей ПО. \n
    2. Sanity-тестирование - это проверка состояния системы в деталях. \n
    3. Тестирование критического пути - это проверка функциональности ПО, которая используется рядовым пользователем. \n
    4. Расширенное тестирование - это проверка функциональности ПО с учетом ее важности. \n\n
    <b>По автоматизации</b> \n
    1. Ручное тестирование \n
    2. Автоматизированное тестирование \n\n\n
    </string>
    <string name="test_method"><b>Метология разработки ПО</b> - это структура, которая систематизирует различные виды проектной деятельности, их взаимодействие и последовательность в процессе разработки ПО. Выбор той или иной модели зависит от масштаба и сложности проекта, предметной области, доступных ресурсов и множества других факторов. Выбор модели разработки ПО серьёзно влияет на процесс тестирования, определяя выбор стратегии, расписание, необходимые ресурсы. \n\n\n
    <b>Каскадная модель</b> \n
    Особенностью данной модели разработки ПО является последовательный переход с одного этапа на другой, только после полного завершения предыдущего этапа. Возврат на предыдущие стадии в данной модели не предусмотрен. \n\n
    <b>V-образная модель</b> \n
    В данной модели разработки каждому этапу разработки соответсвует своя фаза тестирования. Данная модель применима в случае необходимости проведения тщательных проверок. \n\n
    <b>Инкрементальная модель</b> \n
    Это метод, в котором проект проектируется, реализуется и тестируется инкрементно (то есть каждый раз с небольшими добавлениями) до самого окончания разработки. \n\n
    <b>Итерационная модель</b> \n
    Итерационная модель жизненного цикла не требует для начала полной спецификации требований - создание начинается с реализации части функционала, становящейся базой для определения дальнейших требований. Этот процесс повторяется. \n\n
    <b>Спиральная модель</b> \n
    Данная модель похожа на инкрементную, но с акцентом на анализ рисков. Она хорошо работает для решения критически важных бизнес-задач, когда неудача несовместима с деятельностью компании. Модель предполагает четыре этапа для каждого витка - планирование, анализ рисков, конструирование, оценка результатов. \n\n
    <b>Гибкая модель (Agile)</b> \n
    Это собирательное название нескольких разных гибких методологий, основанных на ценностях Agile. Особенностью метода является работа короткими итерациями с последующим анализом и постановкой приоритетов на следующую итерацию. Кажадый цикл состоит из планирования, разработки, тестирования и демонстрации. В случае, если результат удовлетворительный - осуществляется внедрение и переход к следующей итерации. \n\n
    <b>Ценности Agile</b> \n
    1. Люди и их взаимодействие важнее процессов и инструментов. \n
    2. Работающий продукт важнее исчерпывающей документации. \n
    3. Сотрудничество с заказчиком важнее согласования условий контракта. \n
    4. Готовность к изменениям важнее следования плану. \n\n\n
    </string>
    <string name="test_technics"><b>Тест-дизайн</b> - это этап тестирования ПО, на котором создаются тест-кейсы. Целью тест-дизайна является создание наборов тестовых случаев, которые обеспечат максимальное тестовое покрытие. Использование техник тест-дизайна помогает исключить непродуктивные тест-кейсы, сократить общее количество тест-кейсов, прокрыть тестами как можно больше функциональности. \n\n\n
    <b>Классы эквивалентности</b> \n
    Эквивалентное разделение подразумевает разбиение тестовых данных на классы по какому-то признаку. Этот метод имеет смысл только в том случае, если компоненты чем-то похожи и могут войти в общую группу. \n\n
    <b>Анализ граничных значений</b> \n
    Это техника проверки поведения ПО на граничных значениях входных данных. Граничное тестирование также может включать тесты, проверяющие поведение системы на входных данных, выходящих за допустимый диапазон значений. \n\n
    <b>Таблица принятия решений</b> \n
    Таблица принятия решений или матрица решений - способ компактного представления модели со сложной логикой, инструмент для упорядочения сложных бизнес требований, которые должны быть реализованы в продукте. Таблица принятия решений содержит следующие элементы - условия (список возможных условий), варианты (комбинация из выполнения и/или невыполнения условий этого списка) и действия - список возможных действий (вариантов исхода). \n\n
    <b>Таблица состояний и переходов</b> \n
    Таблица переходов представляет собой все возможные комбинации начальных и конечных состояний. Она включает в себя действительные и недействительные переходы, инициирующие события, защитные условия и результирующие действия. \n\n
    <b>Попарное тестирование</b> \n
    Техника основана на комбинаторике и разделении входных параметров «по парам». Проводится комбинирование вариантов и подбор нужных, то есть оцениваются все возможные комбинации (сочетания) входных переменных, и из них выбираются только нужные (значимые). \n\n
    <b>Сценариии использования</b> \n
    Это перечень действий, сценарий по которому пользователь взаимодействует с приложением, программой для выполнения какого-либо действия для достижения конкретной цели. Тестирование по сценариям проводится для того, чтобы обнаружить дополнительные логические дыры и баги в приложении, которые сложно найти в тестировании индивидуальных модулей, частей приложения отдельно друг от друга. \n\n
    <b>Предугадывание ошибок</b> \n
    Этот подход основан на опыте использования других аналогичных приложений/платформ. Предполагается, что тестировщик знает некоторые ситуации, которые могут вызвать ошибки и запутать пользователя с неожиданными результатами. \n\n
    <b>Исследовательское тестирование</b> \n
    Хотя исследовательское тестирование это более креативный вид, чем скриптовое, все же следует придерживаться известных правил и техник, чтобы не упустить из виду дефекты. \n
    1. Принцип декомпозиции - разбиение большого на малые, простые части. Отдельные блоки тестировать гораздо легче, чем все вместе сразу. \n
    2. Тест-туры Джеймса Виттакера - если вы ищете что-то определенное, то обязательно найдете это. \n
    3. Чит-листы - универсальные (в отличие от чек-листов) списки проверок. \n
    4. Мнемоника - разнообразные способы запоминания. \n
    5. Сессионное тестирование - ПО тестируется определенное время, и с каждой сессией происходит углубление в продукт все сильнее. \n\n\n
    </string>
    <string name="test_documentation"><b>Тестовая документация</b> - это набор документов, который создается на протяжении всего цикла тестирования. Документация помогает команде однозначно трактовать шаги, сроки тестирования, результаты, обращаться к этой информации в спорных моментах. \n\n\n
    <b>Стратегия тестирования</b> - статический документ высокого уровня (high-level), обычно разрабатываемый менеджером проекта (project manager). Это документ, который отражает подход к тестированию продукта и достижению целей. Обычно он выводится из Спецификации бизнес-требований (BRS - Business Requirement Specification). На основе стратегии тестирования готовится план тестирования. \n\n
    <b>План тестирования</b> - документ, который содержит план всех действий по тестированию, которые необходимо выполнить для получения качественного продукта. \n\n
    <b>Тестовый набор</b> - некоторый набор формализованных Test case, объединенных между собой по общему логическому признаку. \n\n
    <b>Тестовый случай</b> - набор положительных и отрицательных исполняемых шагов тестового сценария, который имеет набор предварительных условий, тестовых данных, ожидаемого результата, пост-условий и фактических результатов. \n\n
    <b>Чек-лист</b> - перечень формализованных Test case в упрощенном виде удобном для проведения проверок, часто только список из заголовков кейсов. \n\n
    <b>Матрица прослеживаемости требований</b> - документ, который соотносит требования с тестовыми примерами. \n\n
    <b>Отчет о дефектах</b> - цель документа заключается в том, чтобы зафиксировать факт ошибки и передать разработчикам подробную информацию о ней. \n\n
    <b>Отчет о завершении тестирования</b> - содержит подробный анализ обнаруженных ошибок, удаленных ошибок и несоответствий, обнаруженных в программном обеспечении. \n\n
    <b>Руководство пользователя</b> - это руководство помогает конечному пользователю понять как пользоваться продуктом. \n\n\n
    </string>

</resources>

